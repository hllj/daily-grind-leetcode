{"id":317532292,"lang":"cpp","time":"2 years, 3 months","timestamp":1585588359,"status_display":"Wrong Answer","runtime":"N/A","url":"/submissions/detail/317532292/","is_pending":"Not Pending","title":"Frog Jump","memory":"N/A","code":"class Solution {\npublic:\n    bool canCross(vector<int>& stones) {\n        typedef pair <int, int> ii;\n        int n = stones.size();\n        queue <ii> q;\n        q.push(ii(stones[0], 0));\n        set <int> visited;\n        while (!q.empty()) {\n            ii u = q.front();\n            q.pop();\n            int pos = u.first;\n            int k = u.second;\n            if (pos == stones[n - 1]) {\n                return true;\n            }\n            if (binary_search(stones.begin(), stones.end(), pos + k - 1) && visited.count(pos + k - 1) == 0) {\n               q.push(ii(pos + k - 1, k - 1));\n                visited.insert(pos + k - 1);\n            }\n            if (binary_search(stones.begin(), stones.end(), pos + k) && visited.count(pos + k) == 0) {\n               q.push(ii(pos + k, k)); \n                visited.insert(pos + k);\n            }\n            if (binary_search(stones.begin(), stones.end(), pos + k + 1) && visited.count(pos + k + 1) == 0) {\n               q.push(ii(pos + k + 1, k + 1)); \n                visited.insert(pos + k + 1);\n            }\n        }\n        return false;\n    }\n};","compare_result":"111111101111110111111111111111111111111","title_slug":"frog-jump"}